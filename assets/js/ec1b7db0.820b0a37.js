"use strict";(self.webpackChunkir_docs=self.webpackChunkir_docs||[]).push([[5285],{2251:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"reactotron/contributing/monorepo","title":"Monorepo Structure","description":"Yarn 4","source":"@site/docs/reactotron/contributing/monorepo.md","sourceDirName":"reactotron/contributing","slug":"/reactotron/contributing/monorepo","permalink":"/reactotron/contributing/monorepo","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"Reactotron","previous":{"title":"Architecture","permalink":"/reactotron/contributing/architecture"},"next":{"title":"Releasing","permalink":"/reactotron/contributing/releasing"}}');var r=t(4848),o=t(8453);const s={},c="Monorepo Structure",a={},d=[{value:"Yarn 4",id:"yarn-4",level:2},{value:"nodeLinker",id:"nodelinker",level:3},{value:"Patches",id:"patches",level:3},{value:"Nx",id:"nx",level:2},{value:"Tasks",id:"tasks",level:3},{value:"Affected",id:"affected",level:3},{value:"project.json",id:"projectjson",level:3},{value:"Task Caching",id:"task-caching",level:3},{value:"Linting",id:"linting",level:2},{value:"Typescript",id:"typescript",level:2},{value:"Common Gotchas",id:"common-gotchas",level:3},{value:"Prettier",id:"prettier",level:2},{value:"Ignore file",id:"ignore-file",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"monorepo-structure",children:"Monorepo Structure"})}),"\n",(0,r.jsx)(n.h2,{id:"yarn-4",children:"Yarn 4"}),"\n",(0,r.jsxs)(n.p,{children:["This project uses yarn 4 workspaces to manage the monorepo. It hoists dependencies shared across workspaces to the root of the project, and allows for a single ",(0,r.jsx)(n.code,{children:"yarn.lock"})," file to be used for all packages."]}),"\n",(0,r.jsxs)(n.p,{children:["As long as you have yarn 1 installed, you will use the yarn 4 automatically using the version specified in ",(0,r.jsx)(n.code,{children:".yarnrc.yml"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"nodelinker",children:"nodeLinker"}),"\n",(0,r.jsxs)(n.p,{children:["Yarn 4 philosophically has chosen to go in a direction where dependencies should be vendored and checked into the repo. This is a departure from the way yarn 1 and npm work, where dependencies are installed in the ",(0,r.jsx)(n.code,{children:"node_modules"})," directory. They call this Plug'n'Play, and it is enabled by default in yarn 4."]}),"\n",(0,r.jsxs)(n.p,{children:["However, this can behavior can be modified through the ",(0,r.jsx)(n.code,{children:"nodeLinker"})," value in ",(0,r.jsx)(n.code,{children:"yarnrc.yml"})," to use ",(0,r.jsx)(n.code,{children:"node-modules"}),", which is the normal behavior for yarn 1 and npm."]}),"\n",(0,r.jsxs)(n.p,{children:["Since yarn 1 is no longer being actively worked on, so we are using yarn 4 with the ",(0,r.jsx)(n.code,{children:"nodeLinker"})," set to ",(0,r.jsx)(n.code,{children:"node-modules"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"patches",children:"Patches"}),"\n",(0,r.jsxs)(n.p,{children:["Yarn 4 has a patching feature similar to ",(0,r.jsx)(n.code,{children:"patch-package"})," through ",(0,r.jsx)(n.code,{children:"yarn patch <package>"}),". You can read more about it here: ",(0,r.jsx)(n.a,{href:"https://yarnpkg.com/cli/patch",children:"https://yarnpkg.com/cli/patch"})]}),"\n",(0,r.jsx)(n.h2,{id:"nx",children:"Nx"}),"\n",(0,r.jsxs)(n.p,{children:["This project uses ",(0,r.jsx)(n.code,{children:"nx"})," as a task runner for the monorepo. Nx has many features, including build integration, dependency graph visualization, and more. You can read more about it here: ",(0,r.jsx)(n.a,{href:"https://nx.dev/",children:"https://nx.dev/"})]}),"\n",(0,r.jsx)(n.h3,{id:"tasks",children:"Tasks"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"npx nx run-many"})," is a common command used to run a command across all workspaces. For example, ",(0,r.jsx)(n.code,{children:"npx nx run-many --target=lint"})," will run the ",(0,r.jsx)(n.code,{children:"lint"})," target in all workspaces. Targets are like npm scripts, but they can be run across multiple workspaces."]}),"\n",(0,r.jsxs)(n.p,{children:["These are aliased as yarn scripts in the root ",(0,r.jsx)(n.code,{children:"package.json"})," file. For example, ",(0,r.jsx)(n.code,{children:"yarn lint"})," will run the ",(0,r.jsx)(n.code,{children:"lint"})," target in all workspaces."]}),"\n",(0,r.jsx)(n.h3,{id:"affected",children:"Affected"}),"\n",(0,r.jsxs)(n.p,{children:["Nx also has a ",(0,r.jsx)(n.code,{children:"affected"})," command that will run a command on all workspaces that have been affected by a change. For example, ",(0,r.jsx)(n.code,{children:"npx nx affected:lint"})," will run the ",(0,r.jsx)(n.code,{children:"lint"})," target in all workspaces that have been affected by a change."]}),"\n",(0,r.jsx)(n.h3,{id:"projectjson",children:"project.json"}),"\n",(0,r.jsxs)(n.p,{children:["Each workspace needs a ",(0,r.jsx)(n.code,{children:"project.json"})," file to register it with nx. This file is used to define the targets for the workspace, and to define the dependencies between workspaces."]}),"\n",(0,r.jsxs)(n.p,{children:["Any script in the ",(0,r.jsx)(n.code,{children:"scripts"})," section of the ",(0,r.jsx)(n.code,{children:"package.json"})," file will be registered as a target in nx. For example, the ",(0,r.jsx)(n.code,{children:"lint"})," script in the ",(0,r.jsx)(n.code,{children:"package.json"})," file will be registered as a target in nx."]}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, you can set target defaults in the root ",(0,r.jsx)(n.code,{children:"nx.json"})," file."]}),"\n",(0,r.jsx)(n.h3,{id:"task-caching",children:"Task Caching"}),"\n",(0,r.jsxs)(n.p,{children:["Nx has a feature called task caching that will cache the output of a task. Nx can fingerprint whether a task like ",(0,r.jsx)(n.code,{children:"build"})," has already run and not changed. The cache is stored in the ",(0,r.jsx)(n.code,{children:"node_modules/.cache/.nx"})," directory. If you want to clear the cache, you can delete the ",(0,r.jsx)(n.code,{children:"node_modules/.cache/.nx"})," directory."]}),"\n",(0,r.jsx)(n.h2,{id:"linting",children:"Linting"}),"\n",(0,r.jsxs)(n.p,{children:["Eslint allows for having a parent config file and then extending it in child config files. This project has a generic Typescript linting setup at the top, and then child projects can extend it and add their own rules (for React, Electron, etc.). Read more about it here: ",(0,r.jsx)(n.a,{href:"https://eslint.org/docs/latest/user-guide/configuring/configuration-files",children:"https://eslint.org/docs/latest/user-guide/configuring/configuration-files"})]}),"\n",(0,r.jsx)(n.h2,{id:"typescript",children:"Typescript"}),"\n",(0,r.jsxs)(n.p,{children:["In order for ",(0,r.jsx)(n.code,{children:"typescript-eslint"})," to work, we use a ",(0,r.jsx)(n.code,{children:"tsconfig.base.json"})," in the parent directory, and then each workspace extends that base with it's own ",(0,r.jsx)(n.code,{children:"tsconfig.json"})," file. But in the parent eslint config, you must declare the location of all the tsconfig.json files in a glob pattern. You can read more here: ",(0,r.jsx)(n.a,{href:"https://typescript-eslint.io/linting/typed-linting/monorepos/#one-tsconfigjson-per-package-and-an-optional-one-in-the-root",children:"https://typescript-eslint.io/linting/typed-linting/monorepos/#one-tsconfigjson-per-package-and-an-optional-one-in-the-root"})]}),"\n",(0,r.jsx)(n.h3,{id:"common-gotchas",children:"Common Gotchas"}),"\n",(0,r.jsxs)(n.p,{children:["In order to prevent nested folders in our ",(0,r.jsx)(n.code,{children:"dist"})," directory, ",(0,r.jsx)(n.code,{children:'"rootDir": ".",'})," needs to be specified in the workspace ",(0,r.jsx)(n.code,{children:"tsconfig.json"})," to avoid the parent ",(0,r.jsx)(n.code,{children:"tsconfig.base.json"})," from being used."]}),"\n",(0,r.jsx)(n.h2,{id:"prettier",children:"Prettier"}),"\n",(0,r.jsx)(n.h3,{id:"ignore-file",children:"Ignore file"}),"\n",(0,r.jsxs)(n.p,{children:["Prettier has a ",(0,r.jsx)(n.code,{children:".prettierignore"})," file that is used to ignore files. This file is used in addition to the ",(0,r.jsx)(n.code,{children:".gitignore"})," file. This is useful for ignoring files that are not checked into git, but still need to be ignored by prettier. Unfortunately, there is no way to extend the ",(0,r.jsx)(n.code,{children:".gitignore"})," file in the ",(0,r.jsx)(n.code,{children:".prettierignore"})," file, so we have to duplicate the entries. See ",(0,r.jsx)(n.code,{children:"copy-prettier-ignore"})," in the root ",(0,r.jsx)(n.code,{children:"package.json"})," script."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var i=t(6540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);