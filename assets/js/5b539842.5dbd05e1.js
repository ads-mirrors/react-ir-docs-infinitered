"use strict";(self.webpackChunkir_docs=self.webpackChunkir_docs||[]).push([[8147],{5531:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reactotron/contributing/releasing","title":"Releasing","description":"Note: this is a document primarily intended for maintainers at Infinite Red.","source":"@site/docs/reactotron/contributing/releasing.md","sourceDirName":"reactotron/contributing","slug":"/reactotron/contributing/releasing","permalink":"/reactotron/contributing/releasing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"Reactotron","previous":{"title":"Monorepo Structure","permalink":"/reactotron/contributing/monorepo"}}');var i=r(4848),t=r(8453);const c={},a="Releasing",o={},l=[{value:"High Level Overview",id:"high-level-overview",level:2},{value:"Git Tags",id:"git-tags",level:3},{value:"Release Branches",id:"release-branches",level:3},{value:"Releasing Artifacts",id:"releasing-artifacts",level:3},{value:"How Releases Are Implemented",id:"how-releases-are-implemented",level:2},{value:"Nx",id:"nx",level:2},{value:"<code>jscutlery/semver</code>",id:"jscutlerysemver",level:2},{value:"CircleCi",id:"circleci",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"releasing",children:"Releasing"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Note: this is a document primarily intended for maintainers at Infinite Red."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"high-level-overview",children:"High Level Overview"}),"\n",(0,i.jsx)(n.h3,{id:"git-tags",children:"Git Tags"}),"\n",(0,i.jsxs)(n.p,{children:["Git tags are used to mark a commit for a release. The format of the git tag is ",(0,i.jsx)(n.code,{children:"<workspace>@<version>"})," (e.g. ",(0,i.jsx)(n.code,{children:"reactotron-app@3.0.0"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["A release commit and a git tag is created for every affected workspace on a release branch: ",(0,i.jsx)(n.code,{children:"master"}),", ",(0,i.jsx)(n.code,{children:"beta"}),", or ",(0,i.jsx)(n.code,{children:"alpha"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Versions for a workspace are determined by the version in the workspace ",(0,i.jsx)(n.code,{children:"package.json."})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "reactotron-app",\n  "version": "3.0.0"\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Would correspond to a git tag ",(0,i.jsx)(n.code,{children:"reactotron-app@3.0.0"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"release-branches",children:"Release Branches"}),"\n",(0,i.jsx)(n.p,{children:"In CI, on every commit to a release branch, a task is run to determine what changed between the current commit and the last commit. If a workspace has changed, then a new release commit and tag will be added to the release branch."}),"\n",(0,i.jsx)(n.p,{children:"So if 3 workspaces change, then 3 release commits are added to the release branch and 3 git tags are created."}),"\n",(0,i.jsx)(n.h3,{id:"releasing-artifacts",children:"Releasing Artifacts"}),"\n",(0,i.jsx)(n.p,{children:"When a new git tag is published, CI will build and publish the workspace artifacts for that tag."}),"\n",(0,i.jsxs)(n.p,{children:["As of writing this, we have two workspaces: ",(0,i.jsx)(n.code,{children:"apps"})," and ",(0,i.jsx)(n.code,{children:"lib"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Artifacts from ",(0,i.jsx)(n.code,{children:"lib"})," workspaces are published to npm."]}),"\n",(0,i.jsxs)(n.p,{children:["Artifacts from ",(0,i.jsx)(n.code,{children:"app"})," workspaces are published to GitHub releases."]}),"\n",(0,i.jsx)(n.h2,{id:"how-releases-are-implemented",children:"How Releases Are Implemented"}),"\n",(0,i.jsx)(n.p,{children:"Releases are implemented using:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://nx.dev/getting-started/intro",children:"nx"})," to manage workspaces and determine which workspaces have changed between commits"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/jscutlery/semver",children:"jscutlery/semver"})," to bump package.json versions, create release commits, and create git tags"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://circleci.com/docs/configuration-reference/",children:"CircleCi"})," to run the release tasks"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"nx",children:"Nx"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"nx"})," has this concept of ",(0,i.jsx)(n.a,{href:"https://nx.dev/core-features/run-tasks#run-tasks",children:"tasks"}),", which are like npm scripts defined in a ",(0,i.jsx)(n.code,{children:"project.json"})," file."]}),"\n",(0,i.jsxs)(n.p,{children:["To be consistent in the ",(0,i.jsx)(n.code,{children:"jscutlery/semver"})," docs, we have defined semantic release target task in the ",(0,i.jsx)(n.code,{children:"projects.json"})," file as ",(0,i.jsx)(n.code,{children:"version"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This can be run with ",(0,i.jsx)(n.code,{children:"npx nx run <project>:version"})," (e.g. ",(0,i.jsx)(n.code,{children:"npx nx run app:version"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["However, normally this will be run using ",(0,i.jsx)(n.code,{children:"npx nx affected --target version --parallel=1 --base HEAD~1 --head HEAD"}),". The ",(0,i.jsx)(n.a,{href:"https://nx.dev/concepts/affected",children:"affected"})," command from ",(0,i.jsx)(n.code,{children:"nx"})," will run the ",(0,i.jsx)(n.code,{children:"version"})," task for the workspaces that have changed between the branches current commit and the last commit."]}),"\n",(0,i.jsx)(n.h2,{id:"jscutlerysemver",children:(0,i.jsx)(n.code,{children:"jscutlery/semver"})}),"\n",(0,i.jsxs)(n.p,{children:["To determine the new version, ",(0,i.jsx)(n.code,{children:"jscutlery/semver"})," will look at the git tags on the repo, and look for an existing tag ",(0,i.jsx)(n.code,{children:"<project>:<version>"})," (e.g. ",(0,i.jsx)(n.code,{children:"app:1.0.0"}),"). If it finds one, it will increment the version number based on the existing git tags."]}),"\n",(0,i.jsxs)(n.p,{children:["Settings for this plugin are managed using the ",(0,i.jsx)(n.code,{children:"nx.json"})," and ",(0,i.jsx)(n.code,{children:"project.json"})," files in a workspace."]}),"\n",(0,i.jsx)(n.h2,{id:"circleci",children:"CircleCi"}),"\n",(0,i.jsxs)(n.p,{children:["CircleCi is used to run the release tasks. The ",(0,i.jsx)(n.code,{children:"config.yml"})," file is located in the ",(0,i.jsx)(n.code,{children:".circleci"})," folder."]}),"\n",(0,i.jsxs)(n.p,{children:["CircleCi is configured to check for whether new release commits and tags are needed on every commit to a release branch: ",(0,i.jsx)(n.code,{children:"master"}),", ",(0,i.jsx)(n.code,{children:"beta"}),", and ",(0,i.jsx)(n.code,{children:"alpha"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Once a new release tag is created, CircleCi will run a job to publish the artifacts for the workspace."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>a});var s=r(6540);const i={},t=s.createContext(i);function c(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);