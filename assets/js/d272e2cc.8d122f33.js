"use strict";(self.webpackChunkir_docs=self.webpackChunkir_docs||[]).push([[5281],{4534:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"gluegun/guides/architecture","title":"Architecting Your Gluegun CLI","description":"There are many ways to architect Gluegun-powered CLIs. This guide is intended to be a living document, collecting the lessons learned along the way of building CLIs with Gluegun. It is not necessarily the only correct way to build a CLI.","source":"@site/docs/gluegun/guides/architecture.md","sourceDirName":"gluegun/guides","slug":"/gluegun/guides/architecture","permalink":"/gluegun/guides/architecture","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Architecting Your Gluegun CLI"},"sidebar":"Gluegun","previous":{"title":"Guides","permalink":"/gluegun/guides/list"},"next":{"title":"Tutorials","permalink":"/gluegun/tutorials/list"}}');var s=o(4848),t=o(8453);const r={title:"Architecting Your Gluegun CLI"},l="Guide: Architecting Your Gluegun CLI",a={},d=[{value:"Commands",id:"commands",level:2},{value:"Commands file structure",id:"commands-file-structure",level:3},{value:"Extensions",id:"extensions",level:2},{value:"Additional Functionality",id:"additional-functionality",level:3},{value:"Performance",id:"performance",level:3},{value:"Additional Topics",id:"additional-topics",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"guide-architecting-your-gluegun-cli",children:"Guide: Architecting Your Gluegun CLI"})}),"\n",(0,s.jsx)(n.p,{children:"There are many ways to architect Gluegun-powered CLIs. This guide is intended to be a living document, collecting the lessons learned along the way of building CLIs with Gluegun. It is not necessarily the only correct way to build a CLI."}),"\n",(0,s.jsxs)(n.p,{children:["If you have ideas, suggestions, or questions, feel free to ",(0,s.jsx)(n.a,{href:"https://github.com/infinitered/gluegun/issues/new",children:"open an issue"}),"!"]}),"\n",(0,s.jsx)(n.h2,{id:"commands",children:"Commands"}),"\n",(0,s.jsx)(n.p,{children:"Commands should be focused on user interaction and not necessarily on implementation details. Don't write your whole app inside a command; instead, parse out user-provided info, then delegate to other functions (which can be provided via extensions, which are described below) to do work."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Do this"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  name: 'world',\n  alias: ['w', 'earth'],\n  run: async (toolbox) => {\n    // in this case, `hello` is provided by an extension\n    const { hello, prompt } = toolbox\n\n    // user interaction is great in a command\n    const isEarthling = await prompt.confirm('Are you an earthling?')\n\n    // delegate the actual work to an extension\n    if (isEarthling) {\n      hello.greetEarthling()\n    } else {\n      hello.greetAlien()\n    }\n  },\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"commands-file-structure",children:"Commands file structure"}),"\n",(0,s.jsxs)(n.p,{children:["Nest commands in a folder structure that mirrors their command line equivalent. Unlike other libraries, we don't use ",(0,s.jsx)(n.code,{children:"index.js"})," for the default command in a folder. Instead, use the same name as the folder. This helps avoid the situation where you might have 12 ",(0,s.jsx)(n.code,{children:"index.js"})," files open in your editor, which is confusing."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Don't do this"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"commands\n  hello\n    index.js\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Do this"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"commands\n  hello\n    hello.js\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Or this"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"commands\n  hello.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"If you have nested commands, keep them all in the folder, like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"commands\n  hello\n    hello.js\n    world.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"You don't have to have a default command for a folder. Gluegun will pick up on it (as of 2.0.0-beta.7)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"commands\n  hello\n    world.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As of Gluegun 4.1.0, you can also nest commands in a ",(0,s.jsx)(n.code,{children:"build"})," folder, if for example you're using TypeScript and want to compile to ",(0,s.jsx)(n.code,{children:"./build"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"extensions",children:"Extensions"}),"\n",(0,s.jsxs)(n.p,{children:['Think of extensions as "drawers" full of tools in your Gluegun toolbox. In the above example, the ',(0,s.jsx)(n.code,{children:"hello"})," extension adds two functions, ",(0,s.jsx)(n.code,{children:"greetEarthling"})," and ",(0,s.jsx)(n.code,{children:"greetAlien"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = (toolbox) => {\n  const { print } = toolbox\n  toolbox.hello = {\n    greetEarthling: () => print.info('Hello, earthling!'),\n    greetAlien: () => print.info('Greetings, alien!'),\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Hint: In most cases, you probably don't want to use ",(0,s.jsx)(n.code,{children:"prompt"})," in your extensions. They should be more general purpose tools and not specific user flows."]})}),"\n",(0,s.jsx)(n.h3,{id:"additional-functionality",children:"Additional Functionality"}),"\n",(0,s.jsx)(n.p,{children:"The above code snippet is a good simple example of an extension. However, as your extensions grow, you'll probably find that they start getting quite large. In that case, you'll probably want to break your functions out into separate folders."}),"\n",(0,s.jsxs)(n.p,{children:["Just like Gluegun itself, we recommend a separate folder for these. Gluegun uses ",(0,s.jsx)(n.code,{children:"src/toolbox"}),", but you can name it whatever makes sense for you. Here's an example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"commands\n  hello\n    world.js\nextensions\n  hello-extension.js\ntoolbox\n  greetings\n    earthling.js\n    martian.js\n    venusian.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can access Gluegun tools by using ",(0,s.jsx)(n.code,{children:"require"})," (or ",(0,s.jsx)(n.code,{children:"import"})," if you're using TypeScript)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { print } = require('gluegun/print')\n\n// toolbox/greetings/earth.js\nmodule.exports = () => print.info('Hello, earthling!'),\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then attach the functions or objects to your toolbox:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// extensions/hello-extension.js\nconst earthling = require('../toolbox/greetings/earthling')\nconst martian = require('../toolbox/greetings/martian')\nconst venusian = require('../toolbox/greetings/venusian')\n\nmodule.exports = (toolbox) => {\n  toolbox.hello = { earthling, martian, venusian }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,s.jsxs)(n.p,{children:['If you use many NPM packages, it\'s a good idea for performance reasons to "hide" ',(0,s.jsx)(n.code,{children:"require"})," statements inside your command ",(0,s.jsx)(n.code,{children:"run"})," functions so only the command that is invoked loads its dependencies. (",(0,s.jsx)(n.a,{href:"https://github.com/aws-amplify/amplify-cli/pull/511",children:"Here"})," is an example that improved Amazon AWS Amplify CLI performance by nearly 2.5x)"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Don't do this"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const R = require('ramda')\n\nmodule.exports = {\n  name: 'mycommand',\n  run: async (toolbox) => {\n    // use Ramda\n  },\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Do this"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  name: 'mycommand',\n  run: async (toolbox) => {\n    const R = require('ramda')\n    // use Ramda\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"require"})," will only load on-demand when the function is run. It will also only load ",(0,s.jsx)(n.code,{children:"ramda"})," once (in the examples given) even if you ",(0,s.jsx)(n.code,{children:"require"})," multiple times. So you can safely ",(0,s.jsx)(n.code,{children:"require('ramda')"})," in as many functions or extensions as you want."]}),"\n",(0,s.jsx)(n.h2,{id:"additional-topics",children:"Additional Topics"}),"\n",(0,s.jsx)(n.p,{children:"The topics above will get you very far. Some other things to consider as you dig deeper into your CLI are:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Where do I access and store configuration values?"}),"\n",(0,s.jsxs)(n.li,{children:["How do consumers of my CLI install and configure ",(0,s.jsx)(n.a,{href:"/gluegun/plugins",children:"plugins"}),"?"]}),"\n",(0,s.jsxs)(n.li,{children:["How will templates be organized? (Hint: look at the ",(0,s.jsx)(n.a,{href:"https://github.com/infinitered/gluegun/tree/master/src/cli",children:"Gluegun CLI source"}),")"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>l});var i=o(6540);const s={},t=i.createContext(s);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);