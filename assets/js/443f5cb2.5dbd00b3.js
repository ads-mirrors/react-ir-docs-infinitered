"use strict";(self.webpackChunkir_docs=self.webpackChunkir_docs||[]).push([[7932],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(6540);const c={},d=i.createContext(c);function r(e){const t=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),i.createElement(d.Provider,{value:t},e.children)}},9363:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"react-native-mlkit/face-detection/options","title":"Options","description":"There are various options you can provide to the face detector to customize its behavior. Here\'s an example of what\'s","source":"@site/docs/react-native-mlkit/face-detection/options.md","sourceDirName":"react-native-mlkit/face-detection","slug":"/react-native-mlkit/face-detection/options","permalink":"/react-native-mlkit/face-detection/options","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":300,"frontMatter":{"sidebar_position":300},"sidebar":"React Native MLKit","previous":{"title":"Advanced Usage","permalink":"/react-native-mlkit/face-detection/advanced-usage"},"next":{"title":"Types","permalink":"/react-native-mlkit/face-detection/types"}}');var c=n(4848),d=n(8453);const r={sidebar_position:300},s="Options",o={},a=[{value:"Available Options",id:"available-options",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,d.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.header,{children:(0,c.jsx)(t.h1,{id:"options",children:"Options"})}),"\n",(0,c.jsx)(t.p,{children:"There are various options you can provide to the face detector to customize its behavior. Here's an example of what's\npossible:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-tsx",children:'import {\n  RNMLKitFaceDetectorOptions,\n  FaceDetectionProvider\n} from "@infinitered/react-native-mlkit-face-detection";\n\nconst CUSTOM_OPTIONS: RNMLKitFaceDetectorOptions = {\n  performanceMode: "accurate",  // \n  landmarkMode: true,\n  classificationMode: true,\n  minFaceSize: 0.01,\n  isTrackingEnabled: true,\n};\n\nfunction App() {\n  return (\n    <FaceDetectionProvider options={CUSTOM_OPTIONS}>\n      {/* rest of your app goes here */}\n    </FaceDetectionProvider>\n  );\n}\n'})}),"\n",(0,c.jsx)(t.h2,{id:"available-options",children:"Available Options"}),"\n",(0,c.jsx)(t.p,{children:"Options for the face detector."}),"\n",(0,c.jsxs)(t.table,{children:[(0,c.jsx)(t.thead,{children:(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.th,{children:"Property"}),(0,c.jsx)(t.th,{children:"Description"}),(0,c.jsx)(t.th,{children:"Type"}),(0,c.jsx)(t.th,{children:"Default"})]})}),(0,c.jsxs)(t.tbody,{children:[(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"performanceMode"})}),(0,c.jsxs)(t.td,{children:["The performance mode for the detector. Determines the trade-off between speed and accuracy. Use ",(0,c.jsx)(t.code,{children:"'fast'"})," for real-time applications where speed is critical, and ",(0,c.jsx)(t.code,{children:"'accurate'"})," for applications where higher accuracy is desired at the expense of speed."]}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"'fast' | 'accurate'"})}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"fast"})})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"landmarkMode"})}),(0,c.jsx)(t.td,{children:"Indicates if landmark detection should be enabled."}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"boolean | null"})}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"null"})})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"contourMode"})}),(0,c.jsx)(t.td,{children:"Indicates if contour detection should be enabled."}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"boolean | null"})}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"null"})})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"classificationMode"})}),(0,c.jsx)(t.td,{children:"Indicates if classification mode should be enabled."}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"boolean | null"})}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"null"})})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"minFaceSize"})}),(0,c.jsx)(t.td,{children:"Minimum size of the face for detection."}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"number | null"})}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"null"})})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"isTrackingEnabled"})}),(0,c.jsx)(t.td,{children:"Indicates if tracking should be enabled for detected faces."}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"boolean | null"})}),(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"null"})})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}}}]);